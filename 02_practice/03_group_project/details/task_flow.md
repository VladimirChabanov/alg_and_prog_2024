## Сценарии

Пользователь может находится в одном из состояний:

Неизвестный --(обращение к сервису)--> Анонимный --(вход)--> Авторизованный --(выход)--> Не известный.

<br/>

#### Пользователь обращается к системе через новый браузер или после выхода (неизвестный пользователь)

1. Пользователь открывает браузер и указывает адрес модуля *Web клиент* (любой *url*);
2. Браузер отправляет запрос на компонент *Nginx*. При этом браузер автоматически оправляет куки;
3. *Nginx* перенаправляет запрос одной из рабочих копий компонента *Web Client*;
4. *Web Client* делает запрос к компоненту *Redis* используя токен сессии из кук в качестве ключа. Если нужную куку не прислали, то запрос не делаем, а сразу считаем, что ответ от *Redis* отрицательный;
5. *Redis* сообщает, что такого ключа нет;
6. Если *URL* `/`:
   - Показываем пользователю страницу на которой пользователю предлагается авторизоваться через: GitHub, Яндекс ID или через код;
7. Если *URL* `/login` без параметров или любой другой:
   - *Web Client* отвечает браузеру редирект на главную;
8. Если *URL* `/login` с параметром `type`:
   - Генерируем новый токен сессии и новый токен входа;
   - Делаем запрос *Redis* чтобы он запомнил токен сессии как ключ, а в качестве значения: статус пользователя: Анонимный и токен входа;
   - *Web Client* делает запрос к модулю Авторизации (указывая токен входа);
   - Ждём ответа от модуль Авторизации и перенаправляем его браузеру. К ответу также добавляется просьба браузеру запомнить новый токен сессии в куки.

#### Пользователь обращается к системе через браузер (имея статус Анонимный)

1. Пользователь открывает браузер и указывает адрес модуля *Web клиент* (любой *url*);

2. Браузер отправляет запрос на компонент *Nginx*. При этом браузер автоматически оправляет куки;

3. *Nginx* перенаправляет запрос одной из рабочих копий компонента *Web Client*;

4. *Web Client* делает запрос к компоненту *Redis* используя токен сессии из кук в качестве ключа. На этот раз он 100% есть, иначе продолжение по сценарию Неизвестного пользователя.

5. *Redis* сообщает, что такой ключ есть и присылает данные соответствующие ключу;

6. *Web Client* достаёт из ответа статус пользователя. Он равен: Анонимный;

7. Если *URL* `/login` с параметром `type`:

   - Генерируем новый токен входа. Токен сессии остаётся прежний;

   - Делаем запрос *Redis* чтобы он обновил токен входа. В качестве ключа используется текущий токен сессии;

   - *Web Client* делает запрос к модулю Авторизации (указывая токен входа);

   - Ждём ответа от модуль Авторизации и перенаправляем его браузеру.

8. Если *URL* `/login` без параметров или любой другой:

9. *Web Client* достаёт из ответа от *Redis* токен входа и делает запрос модулю Авторизации отправляя токен входа для проверки;

10. Модуль Авторизации проверяет есть ли у него запись для указанного токена входа и отвечает.

11. Если ответ от модуля Авторизации: не опознанный токен или время действия токена закончилось:

    - *Web Client* делает запрос *Redis*, чтобы он удалил текущий ключ. В качестве ключа используется токен сессии. Пользователь переходит в статус Неизвестный.
    - *Web Client* отвечает браузеру редирект на главную;

12. Если ответ от модуля Авторизации: в доступе отказано (пользователь нажал Нет во время входа):

    - *Web Client* делает запрос *Redis*, чтобы он удалил текущий ключ. В качестве ключа используется токен сессии. Пользователь переходит в статус Неизвестный.
    - *Web Client* отвечает браузеру редирект на главную;

13. Если ответ от модуля Авторизации: доступ предоставлен (пользователь нажал Да во время входа), то:

    - *Web Client* проверяет, что в ответе от модуля авторизации присутствуют 2 *JWT* токена: токен доступа (*Access Token*) и токен обновления (*Refresh Token*);
    - Они присутствуют. *Web Client* меняет статус пользователя на Авторизованный и делает запрос *Redis* сохранить новый статус пользователя и оба *JWT* токена (токен входа больше не нужен). В качестве ключа используется токен сессии;
    - *Web Client* продолжает обрабатывать текущий запрос пользователя так, как будто бы пользователь сразу был в статусе Авторизованный.

#### Пользователь обращается к системе через браузер (имея статус Авторизованный)

1. Пользователь открывает браузер и указывает адрес модуля *Web клиент* (любой *url*);
2. Браузер отправляет запрос на компонент *Nginx*. При этом браузер автоматически оправляет куки;
3. *Nginx* перенаправляет запрос одной из рабочих копий компонента *Web Client*;
4. *Web Client* делает запрос к компоненту *Redis* используя токен сессии из кук в качестве ключа. На этот раз он 100% есть, иначе продолжение по сценарию Неизвестного пользователя.
5. *Redis* сообщает, что такой ключ есть и присылает данные соответствующие ключу;
6. *Web Client* достаёт из ответа статус пользователя. Он равен: Авторизованный;
7. Если *URL* `/`:
   - *Web Client* отвечает браузеру страницей личного кабинета пользователя (информация о пользователе, список его дисциплин, и т.д.);
8. Если *URL* `/login` не важно с параметром или без:
   - *Web Client* отвечает браузеру редирект на главную `/`;
9. Если *URL* `/logout` без параметров (выйти из системы на этом устройстве):
   - *Web Client* делает запрос к компоненту *Redis* и просит удалить ключ. В качестве ключа используется токен сессии. Пользователь переходит в статус Неизвестный.
   - *Web Client* отвечает браузеру редирект на главную `/`;
10. Если *URL* `/logout` с параметром `all=true` (выйти из системы на всех устройствах):

       - *Web Client* делает запрос к компоненту *Redis* и просит удалить ключ. В качестве ключа используется токен сессии. Пользователь переходит в статус Неизвестный.
       - *Web Client* делает запрос к модулю Авторизации на `/logout` и отправляет ему токен обновления;
       - *Web Client* отвечает браузеру редирект на главную `/`;
11. Если *URL* другой (самостоятельно назначить для каждого действия которое можно выполнить в системе):
    - *Web Client* делает соответствующий запрос к Главному модулю передавая токен доступа в заголовках запроса;
    - Если токен доступа не устарел и у пользователя есть право на выполнение действия:
      - Главный модуль обрабатывает запрос и отвечает данными;
      - *Web Client* формирует страницу ответа на основе данных и отправляет её браузеру;
    - Если токен доступа не устарел, но у пользователя нет права на выполнение действия:
      - Главный модуль отвечает 403 кодом;
      - *Web Client* формирует страницу с сообщением об отсутствии доступа и отвечает браузеру;
    - Если токен доступа устарел:
      - Главный модуль отвечает 401 кодом;
      - *Web Client* формирует запрос к модулю Авторизации и отправляет токен обновления.
        - Если токен обновления устарел или не существует:
          - Модуль Авторизации отвечает 401 кодом и удаляет у себя устаревший токен;
          - Web Client отправляет запрос *Redis* и просит удалить указанный ключ. Ключ - это токен сесии. Пользователь переходит в статус Неизвестный;
          - *Web Client* отвечает браузеру редирект на главную `/`;
        - Если токен обновления валидный:
          - Модуль Авторизации создаёт новую пару токен доступа + токен обновления и заменяет у себя старый токен обновления новым. Новую пару отправляет в качестве ответа;
          - Web Client отправляет запрос *Redis* и просит заменить токены на новые для указанного ключа. Ключ - это токен сессии;
          - Повторно пытаемся выполнить запрос пользователя (переходим в начало этого пункта);

<br/>

#### Пользователь обращается к системе через Telegram в первый раз или после выхода (неизвестный пользователь)

1. Пользователь через приложение Telegram отправляет сообщение (любое) на сервера Telegram;
2. Компонент *Telegram Client* обращается к серверам Telegram и получает список всех новых сообщений;
3. Компонент *Telegram Client* достаёт из списка новых сообщений наше (предполагается, что оно первое в списке) затем обрабатываются остальные;
4. Компонент *Telegram Client* проверяет сообщение пользователя на предусмотренное в боте.
5. Если мы не предусмотрели ответ на такое сообщение, то отвечаем:
   - Нет такой команды;
6. Если обработчик для сообщения пользователя найден, то *Telegram Client* перенаправляет запрос компоненту *Bot Logic* (перед ним сидит компонент *Nginx*);
7. *Nginx* перенаправляет запрос одной из рабочих копий компонента *Bot Logic*;
8. *Bot Logic* делает запрос к компоненту *Redis* используя `chat_id` в качестве ключа. `chat_id` присылается сервером Telegram вместе с сообщением пользователя. Он всегда одинаковый для пары пользователь-бот и позволяет однозначно идентифицировать пользователя;
9. *Redis* сообщает, что такого ключа нет;
10. Если обработчик `login` без параметров или любой другой:
    - *Bot Logic* формирует ответ сообщающий, что пользователь не заголинен и предлагающий пользователю авторизоваться через: GitHub, Яндекс ID или через код; Ответ уходит пользователю.
11. Если обработчик `login` с параметром `type`:
    - Генерируем новый токен входа;
    - Делаем запрос *Redis* чтобы он запомнил текущий `chat_id` как ключ, а в качестве значения: статус пользователя: Анонимный и токен входа;
    - *Bot Logic* делает запрос к модулю Авторизации (указывая токен входа);
    - Ждём ответа от модуль Авторизации и перенаправляем его пользователю.

#### Пользователь обращается к системе через Telegram (имея статус Анонимный)

1. Пользователь через приложение Telegram отправляет сообщение (любое) на сервера Telegram;
2. Компонент *Telegram Client* обращается к серверам Telegram и получает список всех новых сообщений;
3. Компонент *Telegram Client* достаёт из списка новых сообщений наше (предполагается, что оно первое в списке) затем обрабатываются остальные;
4. Компонент *Telegram Client* проверяет сообщение пользователя на предусмотренное в боте.
5. Если мы не предусмотрели ответ на такое сообщение, то отвечаем:
   - Нет такой команды;
6. Если обработчик для сообщения пользователя найден, то *Telegram Client* перенаправляет запрос компоненту *Bot Logic* (перед ним сидит компонент *Nginx*);
7. *Nginx* перенаправляет запрос одной из рабочих копий компонента *Bot Logic*;
8. *Bot Logic* делает запрос к компоненту *Redis* используя `chat_id` в качестве ключа. На этот раз он 100% есть, иначе продолжение по сценарию Неизвестного пользователя;
9. *Redis* сообщает, что такой ключ есть и присылает данные соответствующие ключу;
10. *Bot Logic* достаёт из ответа статус пользователя. Он равен: Анонимный;
11. Если обработчик `login` с параметром `type`:
    - Генерируем новый токен входа;
    - Делаем запрос *Redis* чтобы он заменил текущий токен входа на новый для ключа `chat_id`;
    - *Bot Logic* делает запрос к модулю Авторизации (указывая токен входа);
    - Ждём ответа от модуль Авторизации и перенаправляем его пользователю.
12. Если обработчик `login` без параметров или любой другой:
13. *Bot Logic* достаёт из ответа от *Redis* токен входа и делает запрос модулю Авторизации отправляя токен входа для проверки;
14. Модуль Авторизации проверяет есть ли у него запись для указанного токена входа и отвечает;
15. Если ответ от модуля Авторизации: не опознанный токен или время действия токена закончилось:
    - *Bot Logic* делает запрос *Redis*, чтобы тот удалил ключ `chat_id`. Пользователь переходит в статус Неизвестный;
    - *Bot Logic* формирует ответ сообщающий, что пользователь не заголинен и предлагающий пользователю авторизоваться через: GitHub, Яндекс ID или через код; Ответ уходит пользователю.
16. Если ответ от модуля Авторизации: в доступе отказано (пользователь нажал Нет во время входа):
    - *Bot Logic* делает запрос *Redis*, чтобы тот удалил ключ `chat_id`. Пользователь переходит в статус Неизвестный;
    - *Bot Logic* формирует ответ сообщающий: неудачная авторизация; Ответ уходит пользователю;
17. Если ответ от модуля Авторизации: доступ предоставлен (пользователь нажал Да во время входа), то:
    - *Bot Logic* проверяет, что в ответе от модуля авторизации присутствуют 2 *JWT* токена: токен доступа (*Access Token*) и токен обновления (*Refresh Token*);
    - Они присутствуют. *Bot Logic* меняет статус пользователя на Авторизованный и делает запрос *Redis* сохранить новый статус пользователя и оба *JWT* токена (токен входа больше не нужен). В качестве ключа используется `chat_id`;
    - *Bot Logic* продолжает обрабатывать текущий запрос пользователя так, как будто бы пользователь сразу был в статусе Авторизованный.

#### Пользователь обращается к системе через Telegram (имея статус Авторизованный)

1. Пользователь через приложение Telegram отправляет сообщение (любое) на сервера Telegram;
2. Компонент *Telegram Client* обращается к серверам Telegram и получает список всех новых сообщений;
3. Компонент *Telegram Client* достаёт из списка новых сообщений наше (предполагается, что оно первое в списке) затем обрабатываются остальные;
4. Компонент *Telegram Client* проверяет сообщение пользователя на предусмотренное в боте.
5. Если мы не предусмотрели ответ на такое сообщение, то отвечаем:
   - Нет такой команды;
6. Если обработчик для сообщения пользователя найден, то *Telegram Client* перенаправляет запрос компоненту *Bot Logic* (перед ним сидит компонент *Nginx*);
7. *Nginx* перенаправляет запрос одной из рабочих копий компонента *Bot Logic*;
8. *Bot Logic* делает запрос к компоненту *Redis* используя `chat_id` в качестве ключа. На этот раз он 100% есть, иначе продолжение по сценарию Неизвестного пользователя;
9. *Redis* сообщает, что такой ключ есть и присылает данные соответствующие ключу;
10. *Bot Logic* достаёт из ответа статус пользователя. Он равен: Авторизованный;
11. Если обработчик `login` не важно с параметром `type` или без, то *Bot Logic* формирует ответ сообщающий: вы уже авторизованы; Ответ уходит пользователю;
12. Если обработчик `logout` без параметров (выйти из системы на этом устройстве):
    - *Bot Logic* делает запрос к компоненту *Redis* и просит удалить ключ. В качестве ключа используется `chat_id`. Пользователь переходит в статус Неизвестный.
    - *Вot Logic* формирует ответ сообщающий: сеанс завершён; Ответ уходит пользователю;
13. Если обработчик `logout` с параметром `all=true` (выйти из системы на всех устройствах):
    - *Bot Logic* делает запрос к компоненту *Redis* и просит удалить ключ. В качестве ключа используется `chat_id`. Пользователь переходит в статус Неизвестный.
    - *Bot Logic* делает запрос к модулю Авторизации на `/logout` и отправляет ему токен обновления;
    - *Вot Logic* формирует ответ сообщающий: сеанс завершён на всех устройствах; Ответ уходит пользователю;
14. Если обработчик другой (самостоятельно назначить для каждого действия которое можно выполнить в системе):
    - *Вot Logic* делает соответствующий запрос к Главному модулю передавая токен доступа в заголовках запроса;
    - Если токен доступа не устарел и у пользователя есть право на выполнение действия:
      - Главный модуль обрабатывает запрос и отвечает данными;
      - *Вot Logic* формирует ответ на основе данных. Ответ уходит пользователю;
    - Если токен доступа не устарел, но у пользователя нет права на выполнение действия:
      - Главный модуль отвечает 403 кодом;
      - *Вot Logic* формирует ответ: не достаточно прав для этого действия. Ответ уходит пользователю;
    - Если токен доступа устарел:
      - Главный модуль отвечает 401 кодом;
      - *Вot Logic* формирует запрос к модулю Авторизации и отправляет токен обновления.
        - Если токен обновления устарел или не существует:
          - Модуль Авторизации отвечает 401 кодом и удаляет у себя устаревший токен;
          - *Вot Logic* отправляет запрос *Redis* и просит удалить указанный ключ. В качестве ключа используется `chat_id`. Пользователь переходит в статус Неизвестный;
          - *Bot Logic* формирует ответ сообщающий, что пользователь не заголинен и предлагающий пользователю авторизоваться через: GitHub, Яндекс ID или через код; Ответ уходит пользователю.
        - Если токен обновления валидный:
          - Модуль Авторизации создаёт новую пару токен доступа + токен обновления и заменяет у себя старый токен обновления новым. Новую пару отправляет в качестве ответа;
          - *Вot Logic* отправляет запрос *Redis* и просит заменить токены на новые для указанного ключа. В качестве ключа используется `chat_id`;
          - Повторно пытаемся выполнить запрос пользователя (переходим в начало этого пункта);

#### Циклические запросы внутри модуля Telegram клиент (проверка входа)

Компонент *Telegram Client* обрабатывает не только запросы от пользователей но и периодически срабатывает по таймеру.

1. Сработал таймер компонента *Telegram Client*;
2. *Telegram Client* делает запрос компоненту *Bot Logic* (перед ним сидит компонент *Nginx*);
3. *Nginx* перенаправляет запрос одной из рабочих копий компонента *Bot Logic*;
4. *Bot Logic* обращается к *Redis* и просит у него всех пользователей находящихся в статусе Анонимный;
5. Для каждого Анонимного пользователя делаем запрос к модулю Авторизации отправляя токен входа для проверки;
   - Если модуль авторизации ответил: не опознанный токен или время действия токена закончилось:
     - *Bot Logic* делает запрос *Redis*, чтобы тот удалил ключ `chat_id`. Пользователь переходит в статус Неизвестный;
   - Если модуль авторизации ответил: в доступе отказано (пользователь нажал Нет во время входа):
     - *Bot Logic* делает запрос *Redis*, чтобы тот удалил ключ `chat_id`. Пользователь переходит в статус Неизвестный;
     - *Bot Logic* добавляет в массив/словарь ответов: `chat_id` и Статус входа: неудачная авторизация; 
   - Если ответ от модуля Авторизации: доступ предоставлен (пользователь нажал Да во время входа), то:
     - *Bot Logic* проверяет, что в ответе от модуля авторизации присутствуют 2 *JWT* токена: токен доступа (*Access Token*) и токен обновления (*Refresh Token*);
     - Они присутствуют. *Bot Logic* меняет статус пользователя на Авторизованный и делает запрос *Redis* сохранить новый статус пользователя и оба *JWT* токена (токен входа больше не нужен). В качестве ключа используется `chat_id`;
     - *Bot Logic* добавляет в массив/словарь ответов: `chat_id` и Статус входа: успешная авторизация; 
6. *Bot Logic* отправляет компоненту *Telegram Client* массив/словарь ответов;
7. *Telegram Client* отправляет сообщение каждому пользователю из полученного массива/словаря.

#### Циклические запросы внутри модуля Telegram клиент (проверка уведомлений)

1. Сработал таймер компонента *Telegram Client*;
2. *Telegram Client* делает запрос компоненту *Bot Logic* (перед ним сидит компонент *Nginx*);
3. *Nginx* перенаправляет запрос одной из рабочих копий компонента *Bot Logic*;
4. *Bot Logic* обращается к *Redis* и просит у него всех пользователей находящихся в статусе Авторизованный;
5. Для каждого Авторизованного пользователя делаем запрос к Главному модулю на *URL* `/notification` отправляя его *JWT* токен доступа:
   - Если для текущего пользователя есть уведомления, *Bot Logic* добавляет их в массив/словарь ответов: `chat_id` и массив уведомлений;
   - *Bot Logic* отправляет Главному модулю запрос на удаление уведомлений для текущего пользователя отправляя его  *JWT* токен доступа;
6. *Bot Logic* отправляет компоненту *Telegram Client* массив/словарь ответов;
7. *Telegram Client* отправляет сообщение каждому пользователю из полученного массива/словаря.

<br/>

#### Модулю Авторизации приходит запрос авторизации пользователя (через GitHub или Яндекс)

Сценарий один и тот же могут быть мелкие отличия в названии параметров (смотрите описание API: [yandex](https://yandex.ru/dev/id/doc/ru/codes/code-url), [github](https://docs.github.com/ru/apps/oauth-apps/building-oauth-apps/authorizing-oauth-apps)).

1. Модулю Авторизации приходит запрос авторизации пользователя с типом *github* или *yandex* и токеном входа (формирует и присылает модуль Telegram клиент или Web клиент);
2. *Authorization Server* берёт ссылку на *github* или *yandex* соответственно, добавляет параметр *client_id* (должен быть получен у *github* и *yandex* во время регистрации приложения) и параметр *state* (равен токену входа);
3. *Authorization Server* формирует структуру из 2 полей: Устареет через: текущее время + 5 минут и Статус ответа от пользователя: не получен. Структура сохраняется в словарь, где в качестве ключа используется токен входа; 
4. *Authorization Server* отправляет в качестве ответе ссылку полученную на шаге 2.

Эта ссылка будет показан пользователю модулем Telegram клиент или Web клиент. Перейдя по ссылке пользователь может подтвердить вход, отказаться от входа или закрыть страницу. Первые два случая приведут к тому, что *github* или *yandex* обратятся к модулю Авторизации и пришлют ошибку (если пользователь отказался) и код (если пользователь согласился). Дополнительно присылается параметр *state* тот, что мы сами указали без изменения.

5. *Authorization Server* получил обращение от *github* или *yandex*:
6. Если пришла ошибка:

   - Берём параметр *state* и используем его в качестве ключа для словаря созданного ранее (если такого ключа нет в словаре, просто игнорируем его) и устанавливаем Статус ответа от пользователя: в доступе отказано;
   - Отвечаем *github* или *yandex* web-страницей сообщающей об неудачной авторизации (страница будет показана пользователю).
7. Если пришёл код:

   - Делаем свой запрос к *github* или *yandex* соответственно и обмениваем код + свои параметры (смотрите API) на токен доступа (этот токен доступа к данным);
   - Делаем второй запрос к *github* или *yandex* соответственно (добавляя токен доступа) и просим прислать данные о пользователе;
   - Если данные пришли достаём почту;
   - Делаем запрос в *mongoDB* и ищем пользователя с соответствующей почтой.
   - Если пользователь есть, то:
     - Достаём данные о его ролях;
   - Если пользователя нет, то:
     - Формируем учётную запись с именем Аноним+номер, ролью "Студент" и пустым список токенов доступа и добавляем её в базу данных;
   
    - Формируем список разрешений на основе ролей пользователя;
   
   
   - Формируем *JWT* токен доступа на основе: списка разрешений, текущего времени + 1 минута (время устаревания токена доступа);
      - Формируем *JWT* токен обновления на основе: почты пользователя, текущего времени + 7*24 часа (время устаревания токена обновления);
   
   - Токен обновления записываем в базу данных в список токенов пользователя;
   - Берём параметр *state* и используем его в качестве ключа для словаря созданного ранее (если такого ключа нет в словаре, просто игнорируем его) и устанавливаем Статус ответа от пользователя: доступ предоставлен и добавляем токен доступа и токен обновления;
   - Отвечаем *github* или *yandex* web-страницей сообщающей об успешной авторизации и предложением перейти обратно в приложение (страница будет показана пользователю).
   

#### Модулю Авторизации приходит запрос авторизации пользователя (через Код)

1. Модулю Авторизации приходит запрос авторизации пользователя с типом *code* и токеном входа (формирует и присылает модуль Telegram клиент или Web клиент);
2. *Authorization Server* делает запрос компоненту *Code Authentication*:
   - *Code Authentication* генерирует случайный код (5-6 цифр) и формирует структуру состоящую из токена входа и текущего времени + 1 минута (время устаревания кода);
   - *Code Authentication* добавляет в словарь новую запись с ключом равным сгенерированному коду и структурой в качестве значения;
   - *Code Authentication* отвечает на запрос от *Authorization Server* сгенерированным кодом.
3. *Authorization Server* формирует структуру из 2 полей: Устареет через: текущее время + 5 минут и Статус ответа от пользователя: не получен. Структура сохраняется в словарь, где в качестве ключа используется токен входа; 
4. *Authorization Server* отправляет в качестве ответа код полученный на шаге 2.

Этот  код должен быть показан Telegram клиентом или Web клиентом (в зависимости от того, кто был инициатором запроса). Пользователь должен взять устройство на котором он авторизован и ввести код или может ничего не делать.

5. Пользователь берёт устройство на котором он авторизован и вводит код;
6. Соответствующий клиент делает запрос компоненту *Code Authentication* (в нашем случае не напрямую а через *Authorization Server*, который просто пересылает запрос) и добавляет туда код и токен обновления;
7. *Code Authentication* достает из запроса код и ищет его в словаре.
8. Если кода нет или он устарел:

   - *Code Authentication* делает запрос компоненту *Authorization Server* и присылает ему ошибку.
9. Если код есть:
   - *Code Authentication* достаёт из запроса токен обновления и проверяет подпись.
   - Если токен отсутствует или токен неправильно подписан *Code Authentication* делает запрос  компоненту *Authorization Server* и присылает ему ошибку.
10. Если всё ок:
    - *Code Authentication* делает запрос  компоненту *Authorization Server* и присылает ему код и *state* равной токену входа.

Далее выполняется всё тоже самое, что и для GitHub и Яндекс начиная с пункта 5. *Code Authentication* на запрос от *Authorization Server* с кодом отправляет почту пользователя которую он достаёт из токена обновления;

11. Ответ от *Authorization Server* пересылается обратно пользователю.

<br/>

#### Приходит запрос к Главному модулю

Главный модуль предоставляет ряд эндпоинтов (маршрутов, *URL*) для каждого действия в системе.

1. Приходит запрос на *URL*;
2. Главный модуль проверяет наличие *JWT* токена доступа;
3. Если токена нет или он устарел или подпись не соответствует содержимому, отправляется ответ 401;
4. Если токен есть и подписан правильно, проверяется наличие в токене разрешение на выполнение действия запрошенного пользователем;
   - Если разрешения нет, то отправляется ответ 403;
   - Если разрешение есть выполняем запрос, получаем/создаём/меняем данные и отправляет ответ. Ответ зависит от запрошенного действия. Список действий и разрешений далее.

<br/>

#### Список действий и разрешений доступных в системе

Система предоставляет доступ к набору ресурсов. С каждым ресурсом можно выполнять определённый набор действий (классическое CRUD). Действие может быть разрешено по умолчанию или запрещено. Если действие запрещено по умолчанию, то можно получить к нему доступ при наличии соответствующего разрешения.

Одно действие может иметь несколько вариаций доступа по умолчанию. Например я могу посмотреть информацию о пользователе, если ID запрашиваемого пользователя совпадает с моим и не могу, если ID другой. Или я могу посмотреть список  студентов записанных на дисциплину, если ID преподавателя дисциплины совпадает с моим и т.п.

Перед выполнением любого действия в системе нужно проверить, есть ли у пользователя доступ по умолчанию или разрешение. Список разрешений пользователя формируется модулем авторизации и записывается в JWT токен доступа. Токен доступа подписывается модулем авторизации, чтобы можно было проверить его подлинность.

Пользователю не присваиваются разрешения по одному. Пользователь получает их группой в соответствии с ролями: Студент, Преподаватель и Админ. Пользователь может иметь одну или более ролей. Каждая роль имеет свой набор разрешений, по сути роли соответствует массив разрешений. Если хоть у одной роли пользователя присутствует разрешение, то пользователь его получает.

##### Ресурс: Пользователи

| Действие                                                    | Эффект                                                       | По умолчанию             | Разрешение            |
| ----------------------------------------------------------- | ------------------------------------------------------------ | ------------------------ | --------------------- |
| Посмотреть список пользователей                             | Возвращает массив содержащий ФИО и ID каждого пользователя зарегистрированного в системе | -                        | `user:list:read`      |
| Посмотреть информацию о пользователе (ФИО)                  | Возвращает ФИО пользователя по его ID                        | + О себе<br />+ О другом |                       |
| Изменить ФИО пользователя                                   | Заменяет ФИО пользователя на указанное по его ID             | + Себе<br />- Другому    | `user:fullName:write` |
| Посмотреть информацию о пользователе (курсы, оценки, тесты) | Возвращает список дисциплин, список тестов, список оценок пользователя по его ID. Возвращается только та информация которую запросили | + О себе<br />- О другом | `user:data:read`      |
| Посмотреть информацию о пользователе (роли)                 | Возвращает массив ролей пользователя по его ID               | - Свои<br />- Чужие      | `user:roles:read`     |
| Изменить роли пользователя                                  | Заменяет роли пользователя на указанные по его ID            | - Себе<br />- Другому    | `user:roles:write`    |
| Посмотреть заблокирован ли пользователь                     | Для пользователя с указанным ID возвращает значение показывающее заблокирован пользователь или нет | - О себе<br />- О другом | `user:block:read`     |
| Заблокировать/Разблокировать пользователя                   | Для пользователя запрещены все действия, даже те, которые разрешены по умолчанию. На любой запрос нужно отвечать кодом 418 | - Себя<br />- Другого    | `user:block:write`    |

##### Ресурс: Дисциплина

| Действие                                                     | Эффект                                                       | По умолчанию                                                 | Разрешение          |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------- |
| Посмотреть список дисциплин                                  | Возвращает массив содержащий Название, Описание и ID каждой дисциплины зарегистрированной в системе | +                                                            |                     |
| Посмотреть информацию о дисциплине (Название, Описание, ID преподавателя) | Возвращает Название, Описание, ID преподавателя для дисциплины по её ID | +                                                            |                     |
| Изменить информацию о дисциплине (Название, Описание)        | Заменяет Название и(или) Описание дисциплины на указанные по её ID | + Для своей дисциплины<br />- Для чужих                      | `course:info:write` |
| Посмотреть информацию о дисциплине (Список тестов)           | Возвращает массив содержащий Название и ID для каждого теста присутствующего в дисциплине по её ID | + Для своей дисциплины<br />+ Для чужих, но если записан на неё<br />- Для чужих | `course:testList`   |
| Посмотреть информацию о тесте (Активный тест или нет)        | Для дисциплины с указанным ID и теста с указанным ID возвращает значение показывающее активен он или нет. Если тест НЕ активен, он отображается в списке, но пройти его нельзя | + Для своей дисциплины<br />+ Для чужих, но если записан на неё<br />- Для чужих | `course:test:read`  |
| Активировать/Деактивировать тест                             | Для дисциплины с указанным ID и теста с указанным ID устанавливает значение активности. Если тест установлен в состояние Не активный, все начатые попытки автоматически отмечаются завершёнными | + Для своей дисциплины<br />- Для чужих                      | `course:test:write` |
| Добавить тест в дисциплину                                   | Добавляет новый тест в дисциплину с ID новый тест с указанным названием, пустым списком вопросов и автором и возвращает ID теста. По умолчанию тест не активен. | + Для своей дисциплины<br />- Для чужих                      | `course:test:add`   |
| Удалить тест из дисциплины                                   | Отмечает тест как удалённый (реально ничего не удаляется). Все оценки перестают отображаться, но тоже не удаляются. | + Для своей дисциплины<br />- Для чужих                      | `course:test:del`   |
| Посмотреть информацию о дисциплине (Список студентов)        | Возвращает массив содержащий ID каждого студента записанного на дисциплину по её ID | + Для своей дисциплины<br />- Для чужих                      | `course:userList`   |
| Записать пользователя на дисциплину                          | Добавляет пользователя с указанным ID на дисциплину с указанным ID | + Себя<br />- Других                                         | `course:user:add`   |
| Отчислить пользователя с дисциплины                          | Отчисляет пользователя с указанным ID с дисциплины с указанным ID | + Себя<br />- Других                                         | `course:user:del`   |
| Создать дисциплину                                           | Создаёт дисциплину с указанным названием, описанием и преподавателем. Как результат возвращает её ID | -                                                            | `course:add`        |
| Удалить дисциплину                                           | Отмечает дисциплину как удалённую (реально ничего не удаляется). Все тесты и оценки перестают отображаться, но тоже не удаляются. | + Для своей дисциплины<br />- Для чужих                      | `course:del`        |

##### Ресурс: Вопросы

Для простоты считаем, что поддерживается только один тип вопросов - вопрос с выбором единственного правильного ответа.

| Действие                                                | Эффект                                                       | По умолчанию                                                 | Разрешение        |
| ------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ----------------- |
| Посмотреть список вопросов                              | Возвращает массив содержащий Название вопроса, его версию и ID автора для каждого теста в системе. Если у вопроса есть несколько версий, показывается только последняя | +Свои<br />- Чужие                                           | `quest:list:read` |
| Посмотреть информацию о вопросе                         | Для указанного ID вопроса и версии возвращает Название, Текст вопроса, Варианты ответов, Номер правильного ответа | + Свои<br />+ Студент у которого есть попытка ответа содержащая этот вопрос<br />- Остальные | `quest:read`      |
| Изменить текст вопроса/ответов (создаётся новая версия) | Для указанного ID вопроса создаёт новую версию с заданным Названием, Тексом вопроса, Вариантами ответов, Номером правильного ответа | + Свои<br />- Чужие                                          | `quest:update`    |
| Создать вопрос                                          | Создаёт новый вопрос с заданным Названием, Тексом вопроса, Вариантами ответов, Номером правильного ответа. Версия вопроса 1. В качестве ответа возвращается ID вопроса | -                                                            | `quest:create`    |
| Удалить вопрос                                          | Если вопрос не используется в тестах (даже удалённых), то вопрос отмечается как удалённый (но реально не удаляется) | + Свой<br />- Чужой                                          | `quest:del`       |

##### Ресурс: Тесты

Тест состоит из `id`, id дисциплины, названия, массива идентификаторов вопросов и массива попыток, состояние теста (актив/не актив), существование теста (существует/удалён). 

| Действие                                       | Эффект                                                       | По умолчанию                                                 | Разрешение          |
| ---------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------- |
| Удалить вопрос из теста                        | Если у теста ещё не было попыток прохождения, то удаляет у теста с указанным ID вопрос с указанным ID | + Если пользователь преподаватель на курсе<br />- Для остальных | `test:quest:del`    |
| Добавить вопрос в тест                         | Если у теста ещё не было попыток прохождения, то добавляет в теста с указанным ID вопрос с указанным ID в последнюю позицию | + Если пользователь преподаватель на курсе и автор вопроса<br />- Для остальных | `test:quest:add`    |
| Изменить порядок следования вопросов в тесте   | Если у теста ещё не было попыток прохождения, то для теста с указанным ID устанавливает указанную последовательность вопросов | + Если пользователь преподаватель на курсе<br />- Для остальных | `test:quest:update` |
| Посмотреть список пользователей прошедших тест | Для теста с указанным ID выбирает все попытки и возвращает ID пользователей выполнивших эти попытки | + Если пользователь преподаватель на курсе<br />- Для остальных | `test:answer:read`  |
| Посмотреть оценку пользователя                 | Для теста с указанным ID выбирает все попытки и возвращает оценки и ID пользователей выполнивших эти попытки | + Если пользователь преподаватель на курсе<br />+ Если пользователь смотрит свою оценку<br />- Для остальных | `test:answer:read`  |
| Посмотреть ответы пользователя                 | Для теста с указанным ID выбирает все попытки и возвращает оценки и ID пользователей выполнивших эти попытки | + Если пользователь преподаватель на курсе<br />+ Если пользователь смотрит свои ответы<br />- Для остальных | `test:answer:read`  |

##### Ресурс: Попытка

Когда пользователь начинает проходить тест, для него автоматически создаётся попытка. Попытка всегда одна. Попытка состоит из id, id пользователя-владельца, идентификатора теста, массива идентификаторов вопросов и их версий, массива ответов, состояние попытки.

Во время создания попытки, выбирается самая последняя версия вопроса с указанным ID.

| Действие           | Эффект                                                       | По умолчанию                                                 | Разрешение         |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------ |
| Создать            | Если пользователь с ID ещё не отвечал на тест с ID и тест находится в активном состоянии, то создаётся новая попытка и возвращается её ID | + Если пользователь отвечающий на тест<br />- Для остальных  | нет                |
| Изменить           | Если тест находится в активном состоянии и пользователь ещё не закончил попытку, то для попытки с ID изменяет значение ответа с ID | + Если пользователь отвечающий на тест<br />- Для остальных  | нет                |
| Завершить попытку  | Если тест находится в активном состоянии и пользователь ещё не закончил попытку, то устанавливает попытку в состояние: завершено.<br />Если тест переключили в состояние не активный, то все попытки для него автоматически устанавливаются в состояние: завершено | + Если пользователь отвечающий на тест<br />- Для остальных  | нет                |
| Посмотреть попытку | Для пользователя с ID и теста с ID возвращается массив ответов и статус состояние попытки | + Если пользователь преподаватель на курсе<br />+ Если пользователь смотрит свои ответы<br />- Для остальных | `test:answer:read` |

##### Ресурс: Ответы

Ответ состоит из id, id вопроса и его версии, id попытки, числового поля для ответа.

| Действие   | Эффект                                                       | По умолчанию                                                 | Разрешение                                                   |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Создать    | Для вопроса с ID создается ответ. Изначально ответ отмечается как `-1` (не определённый). | -                                                            | Нет разрешения. Ответ автоматически создаётся системой во время создания попытки для каждого вопроса. |
| Посмотреть | Возвращает ID вопроса, и индекс выбранного варианта ответа от 0. Значение `-1` - пользователь не дал ответ на вопрос. | + Если пользователь преподаватель на курсе<br />+ Если пользователь смотрит свои ответы<br />- Для остальных | `answer:read`                                                |
| Изменить   | Если попытка которой принадлежит ответ не завершена, то изменяет индекс варианта ответа на указанный. | + Если пользователь отвечающий на тест<br />- Для остальных  | `answer:update`                                              |
| Удалить    | Если попытка которой принадлежит ответ не завершена, то изменяет индекс варианта ответа на `-1`. | + Если пользователь отвечающий на тест<br />- Для остальных  | `answer:del`                                                 |
